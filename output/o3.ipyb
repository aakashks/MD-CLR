{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "61bd657b",
   "metadata": {
    "id": "JC-p4CpT1_Lc",
    "papermill": {
     "duration": 0.008723,
     "end_time": "2024-05-12T01:01:10.803398",
     "exception": false,
     "start_time": "2024-05-12T01:01:10.794675",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Load Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ac189761",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-12T01:01:10.836522Z",
     "iopub.status.busy": "2024-05-12T01:01:10.836237Z",
     "iopub.status.idle": "2024-05-12T01:01:10.841562Z",
     "shell.execute_reply": "2024-05-12T01:01:10.841139Z"
    },
    "id": "gr9MjCphpOPx",
    "papermill": {
     "duration": 0.026636,
     "end_time": "2024-05-12T01:01:10.843437",
     "exception": false,
     "start_time": "2024-05-12T01:01:10.816801",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# where we will unpack data\n",
    "# OUTPUT_FOLDER = \"/kaggle/working/\"\n",
    "# DATA_FOLDER = \"/kaggle/input/solfune-satellite/\"\n",
    "# TRAIN_DATA_FOLDER = DATA_FOLDER + 'train/'\n",
    "\n",
    "OUTPUT_FOLDER = \"/scratch/aakash_ks.iitr/dr-scnn/\"\n",
    "DATA_FOLDER = \"/scratch/aakash_ks.iitr/data/diabetic-retinopathy/\"\n",
    "TRAIN_DATA_FOLDER = DATA_FOLDER + 'resized_train/'\n",
    "# TEST_DATA_FOLDER = DATA_FOLDER + 'test/'"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "87f3f2df",
   "metadata": {
    "id": "dOaKi5h92DBb",
    "papermill": {
     "duration": 0.015648,
     "end_time": "2024-05-12T01:01:10.883265",
     "exception": false,
     "start_time": "2024-05-12T01:01:10.867617",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Imports"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "03865c86",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-12T01:01:10.904631Z",
     "iopub.status.busy": "2024-05-12T01:01:10.904426Z",
     "iopub.status.idle": "2024-05-12T01:01:12.106260Z",
     "shell.execute_reply": "2024-05-12T01:01:12.105724Z"
    },
    "id": "NNdj2cxdkpiv",
    "papermill": {
     "duration": 1.210535,
     "end_time": "2024-05-12T01:01:12.109012",
     "exception": false,
     "start_time": "2024-05-12T01:01:10.898477",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import os\n",
    "import random\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from tqdm import tqdm\n",
    "\n",
    "from PIL import Image"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "fb23d2f1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-12T01:01:12.139915Z",
     "iopub.status.busy": "2024-05-12T01:01:12.139694Z",
     "iopub.status.idle": "2024-05-12T01:01:15.791476Z",
     "shell.execute_reply": "2024-05-12T01:01:15.790863Z"
    },
    "id": "7yoCqGCB2jIS",
    "papermill": {
     "duration": 3.668231,
     "end_time": "2024-05-12T01:01:15.793322",
     "exception": false,
     "start_time": "2024-05-12T01:01:12.125091",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/aakash_ks.iitr/miniconda3/envs/py311/lib/python3.11/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n",
      "  from .autonotebook import tqdm as notebook_tqdm\n"
     ]
    }
   ],
   "source": [
    "import torch\n",
    "import torch.nn.functional as F\n",
    "import torch.nn as nn\n",
    "\n",
    "from torch.utils.data import DataLoader, Dataset, WeightedRandomSampler\n",
    "from torchvision.transforms import v2\n",
    "\n",
    "import timm"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "70d67dc7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-12T01:01:15.814035Z",
     "iopub.status.busy": "2024-05-12T01:01:15.813778Z",
     "iopub.status.idle": "2024-05-12T01:01:15.830878Z",
     "shell.execute_reply": "2024-05-12T01:01:15.830132Z"
    },
    "id": "8Ejzj4rDx_GK",
    "papermill": {
     "duration": 0.02871,
     "end_time": "2024-05-12T01:01:15.832447",
     "exception": false,
     "start_time": "2024-05-12T01:01:15.803737",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "NUM_CLASSES = 5\n",
    "\n",
    "class CFG:\n",
    "    seed = 42\n",
    "    N_folds = 5\n",
    "    train_folds = [0] # [0,1,2,3,4]\n",
    "\n",
    "    device = 'cuda' if torch.cuda.is_available() else 'cpu'\n",
    "    apex=True # use half precision\n",
    "\n",
    "    # model_name = \"maxvit_tiny_tf_512\"\n",
    "    model_name = \"resnet50.a1_in1k\"\n",
    "    epochs = 5\n",
    "    # weights =  torch.tensor([0.206119, 0.793881],dtype=torch.float32)\n",
    "\n",
    "    clip_val = 1000.\n",
    "    batch_size = 64\n",
    "    # gradient_accumulation_steps = 1\n",
    "\n",
    "    lr = 1e-4\n",
    "    weight_decay=1e-2\n",
    "    \n",
    "    resolution = 224"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "a2f5e55d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-05-12T01:01:15.851035Z",
     "iopub.status.busy": "2024-05-12T01:01:15.850466Z",
     "iopub.status.idle": "2024-05-12T01:01:20.540524Z",
     "shell.execute_reply": "2024-05-12T01:01:20.539546Z"
    },
    "papermill": {
     "duration": 3.800099,
     "end_time": "2024-05-12T01:01:19.641376",
     "exception": false,
     "start_time": "2024-05-12T01:01:15.841277",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[34m\u001b[1mwandb\u001b[0m: Currently logged in as: \u001b[33maakashks_\u001b[0m. Use \u001b[1m`wandb login --relogin`\u001b[0m to force relogin\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Problem at: /home/aakash_ks.iitr/miniconda3/envs/py311/lib/python3.11/site-packages/wandb/sdk/wandb_init.py 855 getcaller\n"
     ]
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[5], line 6\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mwandb\u001b[39;00m\n\u001b[1;32m      2\u001b[0m \u001b[38;5;66;03m# from kaggle_secrets import UserSecretsClient\u001b[39;00m\n\u001b[1;32m      3\u001b[0m \u001b[38;5;66;03m# user_secrets = UserSecretsClient()\u001b[39;00m\n\u001b[1;32m      4\u001b[0m \u001b[38;5;66;03m# wandb.login(key=user_secrets.get_secret(\"wandb_api\"))\u001b[39;00m\n\u001b[0;32m----> 6\u001b[0m run \u001b[38;5;241m=\u001b[39m wandb\u001b[38;5;241m.\u001b[39minit(\n\u001b[1;32m      7\u001b[0m     project\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mhello-world\u001b[39m\u001b[38;5;124m\"\u001b[39m, \n\u001b[1;32m      8\u001b[0m     \u001b[38;5;28mdir\u001b[39m\u001b[38;5;241m=\u001b[39mOUTPUT_FOLDER,\n\u001b[1;32m      9\u001b[0m     config\u001b[38;5;241m=\u001b[39m{\n\u001b[1;32m     10\u001b[0m     k:v \u001b[38;5;28;01mfor\u001b[39;00m k, v \u001b[38;5;129;01min\u001b[39;00m CFG\u001b[38;5;241m.\u001b[39m\u001b[38;5;18m__dict__\u001b[39m\u001b[38;5;241m.\u001b[39mitems() \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m k\u001b[38;5;241m.\u001b[39mstartswith(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124m__\u001b[39m\u001b[38;5;124m'\u001b[39m)}\n\u001b[1;32m     11\u001b[0m )\n",
      "File \u001b[0;32m~/miniconda3/envs/py311/lib/python3.11/site-packages/wandb/sdk/wandb_init.py:1210\u001b[0m, in \u001b[0;36minit\u001b[0;34m(job_type, dir, config, project, entity, reinit, tags, group, name, notes, magic, config_exclude_keys, config_include_keys, anonymous, mode, allow_val_change, resume, force, tensorboard, sync_tensorboard, monitor_gym, save_code, id, fork_from, settings)\u001b[0m\n\u001b[1;32m   1208\u001b[0m     \u001b[38;5;28;01massert\u001b[39;00m logger\n\u001b[1;32m   1209\u001b[0m     logger\u001b[38;5;241m.\u001b[39mwarning(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124minterrupted\u001b[39m\u001b[38;5;124m\"\u001b[39m, exc_info\u001b[38;5;241m=\u001b[39me)\n\u001b[0;32m-> 1210\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m e\n\u001b[1;32m   1211\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mException\u001b[39;00m \u001b[38;5;28;01mas\u001b[39;00m e:\n\u001b[1;32m   1212\u001b[0m     error_seen \u001b[38;5;241m=\u001b[39m e\n",
      "File \u001b[0;32m~/miniconda3/envs/py311/lib/python3.11/site-packages/wandb/sdk/wandb_init.py:1187\u001b[0m, in \u001b[0;36minit\u001b[0;34m(job_type, dir, config, project, entity, reinit, tags, group, name, notes, magic, config_exclude_keys, config_include_keys, anonymous, mode, allow_val_change, resume, force, tensorboard, sync_tensorboard, monitor_gym, save_code, id, fork_from, settings)\u001b[0m\n\u001b[1;32m   1185\u001b[0m except_exit \u001b[38;5;241m=\u001b[39m wi\u001b[38;5;241m.\u001b[39msettings\u001b[38;5;241m.\u001b[39m_except_exit\n\u001b[1;32m   1186\u001b[0m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[0;32m-> 1187\u001b[0m     run \u001b[38;5;241m=\u001b[39m wi\u001b[38;5;241m.\u001b[39minit()\n\u001b[1;32m   1188\u001b[0m     except_exit \u001b[38;5;241m=\u001b[39m wi\u001b[38;5;241m.\u001b[39msettings\u001b[38;5;241m.\u001b[39m_except_exit\n\u001b[1;32m   1189\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m (\u001b[38;5;167;01mKeyboardInterrupt\u001b[39;00m, \u001b[38;5;167;01mException\u001b[39;00m) \u001b[38;5;28;01mas\u001b[39;00m e:\n",
      "File \u001b[0;32m~/miniconda3/envs/py311/lib/python3.11/site-packages/wandb/sdk/wandb_init.py:818\u001b[0m, in \u001b[0;36m_WandbInit.init\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m    816\u001b[0m run_start_handle \u001b[38;5;241m=\u001b[39m backend\u001b[38;5;241m.\u001b[39minterface\u001b[38;5;241m.\u001b[39mdeliver_run_start(run\u001b[38;5;241m.\u001b[39m_run_obj)\n\u001b[1;32m    817\u001b[0m \u001b[38;5;66;03m# TODO: add progress to let user know we are doing something\u001b[39;00m\n\u001b[0;32m--> 818\u001b[0m run_start_result \u001b[38;5;241m=\u001b[39m run_start_handle\u001b[38;5;241m.\u001b[39mwait(timeout\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m30\u001b[39m)\n\u001b[1;32m    819\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m run_start_result \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[1;32m    820\u001b[0m     run_start_handle\u001b[38;5;241m.\u001b[39mabandon()\n",
      "File \u001b[0;32m~/miniconda3/envs/py311/lib/python3.11/site-packages/wandb/sdk/lib/mailbox.py:283\u001b[0m, in \u001b[0;36mMailboxHandle.wait\u001b[0;34m(self, timeout, on_probe, on_progress, release, cancel)\u001b[0m\n\u001b[1;32m    280\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_interface\u001b[38;5;241m.\u001b[39m_transport_keepalive_failed():\n\u001b[1;32m    281\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m MailboxError(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mtransport failed\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m--> 283\u001b[0m found, abandoned \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_slot\u001b[38;5;241m.\u001b[39m_get_and_clear(timeout\u001b[38;5;241m=\u001b[39mwait_timeout)\n\u001b[1;32m    284\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m found:\n\u001b[1;32m    285\u001b[0m     \u001b[38;5;66;03m# Always update progress to 100% when done\u001b[39;00m\n\u001b[1;32m    286\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m on_progress \u001b[38;5;129;01mand\u001b[39;00m progress_handle \u001b[38;5;129;01mand\u001b[39;00m progress_sent:\n",
      "File \u001b[0;32m~/miniconda3/envs/py311/lib/python3.11/site-packages/wandb/sdk/lib/mailbox.py:130\u001b[0m, in \u001b[0;36m_MailboxSlot._get_and_clear\u001b[0;34m(self, timeout)\u001b[0m\n\u001b[1;32m    128\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21m_get_and_clear\u001b[39m(\u001b[38;5;28mself\u001b[39m, timeout: \u001b[38;5;28mfloat\u001b[39m) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m Tuple[Optional[pb\u001b[38;5;241m.\u001b[39mResult], \u001b[38;5;28mbool\u001b[39m]:\n\u001b[1;32m    129\u001b[0m     found \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[0;32m--> 130\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_wait(timeout\u001b[38;5;241m=\u001b[39mtimeout):\n\u001b[1;32m    131\u001b[0m         \u001b[38;5;28;01mwith\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_lock:\n\u001b[1;32m    132\u001b[0m             found \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_result\n",
      "File \u001b[0;32m~/miniconda3/envs/py311/lib/python3.11/site-packages/wandb/sdk/lib/mailbox.py:126\u001b[0m, in \u001b[0;36m_MailboxSlot._wait\u001b[0;34m(self, timeout)\u001b[0m\n\u001b[1;32m    125\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21m_wait\u001b[39m(\u001b[38;5;28mself\u001b[39m, timeout: \u001b[38;5;28mfloat\u001b[39m) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m \u001b[38;5;28mbool\u001b[39m:\n\u001b[0;32m--> 126\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_event\u001b[38;5;241m.\u001b[39mwait(timeout\u001b[38;5;241m=\u001b[39mtimeout)\n",
      "File \u001b[0;32m~/miniconda3/envs/py311/lib/python3.11/threading.py:629\u001b[0m, in \u001b[0;36mEvent.wait\u001b[0;34m(self, timeout)\u001b[0m\n\u001b[1;32m    627\u001b[0m signaled \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_flag\n\u001b[1;32m    628\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m signaled:\n\u001b[0;32m--> 629\u001b[0m     signaled \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_cond\u001b[38;5;241m.\u001b[39mwait(timeout)\n\u001b[1;32m    630\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m signaled\n",
      "File \u001b[0;32m~/miniconda3/envs/py311/lib/python3.11/threading.py:331\u001b[0m, in \u001b[0;36mCondition.wait\u001b[0;34m(self, timeout)\u001b[0m\n\u001b[1;32m    329\u001b[0m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[1;32m    330\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m timeout \u001b[38;5;241m>\u001b[39m \u001b[38;5;241m0\u001b[39m:\n\u001b[0;32m--> 331\u001b[0m         gotit \u001b[38;5;241m=\u001b[39m waiter\u001b[38;5;241m.\u001b[39macquire(\u001b[38;5;28;01mTrue\u001b[39;00m, timeout)\n\u001b[1;32m    332\u001b[0m     \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[1;32m    333\u001b[0m         gotit \u001b[38;5;241m=\u001b[39m waiter\u001b[38;5;241m.\u001b[39macquire(\u001b[38;5;28;01mFalse\u001b[39;00m)\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "import wandb\n",
    "# from kaggle_secrets import UserSecretsClient\n",
    "# user_secrets = UserSecretsClient()\n",
    "# wandb.login(key=user_secrets.get_secret(\"wandb_api\"))\n",
    "\n",
    "run = wandb.init(\n",
    "    project=\"hello-world\", \n",
    "    dir=OUTPUT_FOLDER,\n",
    "    config={\n",
    "    k:v for k, v in CFG.__dict__.items() if not k.startswith('__')}\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "77e30181",
   "metadata": {
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "device = torch.device(CFG.device)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fa46eb2e",
   "metadata": {
    "id": "7Ve34id2b7uu",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Load train data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "db5032f5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-14T16:13:55.725554Z",
     "iopub.status.busy": "2024-04-14T16:13:55.725188Z",
     "iopub.status.idle": "2024-04-14T16:13:55.745976Z",
     "shell.execute_reply": "2024-04-14T16:13:55.744974Z",
     "shell.execute_reply.started": "2024-04-14T16:13:55.725520Z"
    },
    "id": "mq-oqFtvkpix",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "train_data = pd.read_csv(os.path.join(DATA_FOLDER, 'trainLabels.csv'))\n",
    "train_data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9dcad32a",
   "metadata": {
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# remove all images from the csv if they are not in the folder\n",
    "lst = map(lambda x: x[:-5], os.listdir(TRAIN_DATA_FOLDER))\n",
    "train_data = train_data[train_data.image.isin(lst)]\n",
    "len(train_data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2f2562d7",
   "metadata": {
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "train_data.level.value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b20c1a02",
   "metadata": {
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# take only 100 samples from each class\n",
    "train_data = train_data.groupby('level').head(100).reset_index(drop=True)\n",
    "train_data.level.value_counts()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "69391c63",
   "metadata": {
    "id": "1Mu24W3Xkpix",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "41499b0e",
   "metadata": {
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from torchvision.transforms import functional as func\n",
    "\n",
    "class CustomTransform:\n",
    "    def __init__(self, output_size=(CFG.resolution, CFG.resolution), radius_factor=0.9):\n",
    "        self.output_size = output_size\n",
    "        self.radius_factor = radius_factor\n",
    "\n",
    "    def __call__(self, img):\n",
    "        # Assuming img is a PIL Image\n",
    "        # Normalize and preprocess as previously defined\n",
    "        img = func.resize(img, int(min(img.size) / self.radius_factor))\n",
    "        img_tensor = func.to_tensor(img)\n",
    "        mean, std = img_tensor.mean([1, 2]), img_tensor.std([1, 2])\n",
    "        img_normalized = func.normalize(img_tensor, mean.tolist(), std.tolist())\n",
    "        kernel_size = 15\n",
    "        padding = kernel_size // 2\n",
    "        avg_pool = torch.nn.AvgPool2d(kernel_size, stride=1, padding=padding)\n",
    "        local_avg = avg_pool(img_normalized.unsqueeze(0)).squeeze(0)\n",
    "        img_subtracted = img_normalized - local_avg\n",
    "        center_crop_size = int(min(img_subtracted.shape[1:]) * self.radius_factor)\n",
    "        img_cropped = func.center_crop(img_subtracted, [center_crop_size, center_crop_size])\n",
    "\n",
    "        # Apply augmentations\n",
    "        img_resized = func.resize(img_cropped, self.output_size)\n",
    "\n",
    "        return img_resized"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8b1b5f7f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-14T16:14:03.100814Z",
     "iopub.status.busy": "2024-04-14T16:14:03.100062Z",
     "iopub.status.idle": "2024-04-14T16:14:03.108402Z",
     "shell.execute_reply": "2024-04-14T16:14:03.107471Z",
     "shell.execute_reply.started": "2024-04-14T16:14:03.100781Z"
    },
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# train_transforms = CustomTransform()\n",
    "\n",
    "train_transforms = v2.Compose([\n",
    "    CustomTransform(),\n",
    "    v2.RandomResizedCrop(CFG.resolution, scale=(0.8, 1.0)),  # Krizhevsky style random cropping\n",
    "    v2.RandomHorizontalFlip(),  # Random horizontal flip\n",
    "    v2.RandomVerticalFlip(),  # Random vertical flip\n",
    "    v2.GaussianBlur(kernel_size=(5, 5), sigma=(0.1, 2)),  # Gaussian blur with random kernel size and sigma\n",
    "    v2.RandomRotation(degrees=(0, 90)),  # Random rotation between 0 and 360 degrees\n",
    "    v2.ToDtype(torch.float32, scale=False),\n",
    "])\n",
    "\n",
    "val_transforms = v2.Compose([\n",
    "    CustomTransform(),\n",
    "    v2.ToDtype(torch.float32, scale=False),\n",
    "])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6f88b2b6",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-14T16:21:34.766966Z",
     "iopub.status.busy": "2024-04-14T16:21:34.766584Z",
     "iopub.status.idle": "2024-04-14T16:21:34.774717Z",
     "shell.execute_reply": "2024-04-14T16:21:34.773808Z",
     "shell.execute_reply.started": "2024-04-14T16:21:34.766935Z"
    },
    "id": "_mAcIdn2kpiy",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "scrolled": true,
    "tags": []
   },
   "outputs": [],
   "source": [
    "class ImageTrainDataset(Dataset):\n",
    "    def __init__(\n",
    "        self,\n",
    "        folder,\n",
    "        data,\n",
    "        transforms,\n",
    "    ):\n",
    "        self.folder = folder\n",
    "        self.data = data\n",
    "        self.transforms = transforms\n",
    "\n",
    "    def __len__(self):\n",
    "        return len(self.data)\n",
    "\n",
    "    def __getitem__(self, index):\n",
    "        d = self.data.loc[index]\n",
    "        image = Image.open(f\"{self.folder}{d.image}.jpeg\")\n",
    "        image = self.transforms(image)\n",
    "        label = d.level\n",
    "\n",
    "        return image, torch.tensor(label, dtype=torch.long)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6ffba5a0",
   "metadata": {
    "id": "OzgB1JpAv3qg",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Loss"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c687143a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-14T16:21:35.486917Z",
     "iopub.status.busy": "2024-04-14T16:21:35.486197Z",
     "iopub.status.idle": "2024-04-14T16:21:35.493226Z",
     "shell.execute_reply": "2024-04-14T16:21:35.492187Z",
     "shell.execute_reply.started": "2024-04-14T16:21:35.486887Z"
    },
    "id": "n0u9VgXTv7VU",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def contrastive_loss(embeddings, labels, margin=1.0):\n",
    "    distance_matrix = torch.cdist(embeddings, embeddings, p=2)  # Compute pairwise Euclidean distances\n",
    "    matches = labels.unsqueeze(0) == labels.unsqueeze(1)  # Matrix where True indicates matching labels\n",
    "    non_matches = ~matches\n",
    "    \n",
    "    # Select positive and negative pairs\n",
    "    positive_distances = distance_matrix[matches].clamp(min=0.00001)  # Clamp to avoid sqrt of zero\n",
    "    negative_distances = distance_matrix[non_matches].clamp(min=0.00001)\n",
    "    \n",
    "    # Calculate losses for all positives and negative pair combinations\n",
    "    positive_loss = torch.mean(positive_distances)\n",
    "    negative_loss = torch.mean(torch.relu(margin - negative_distances))\n",
    "    \n",
    "    # Total loss combines positive and negative contributions\n",
    "    loss = positive_loss + negative_loss\n",
    "    return loss"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8c774a9d",
   "metadata": {
    "id": "Zyfw9PLdkpiz",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Train and evaluate functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "54d882d6",
   "metadata": {
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "class style:\n",
    "    BLUE = '\\033[94m'\n",
    "    GREEN = '\\033[92m'\n",
    "    YELLOW = '\\033[93m'\n",
    "    END = '\\033[0m'\n",
    "    BOLD = '\\033[1m'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2ed036f5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-14T16:21:36.151872Z",
     "iopub.status.busy": "2024-04-14T16:21:36.151533Z",
     "iopub.status.idle": "2024-04-14T16:21:36.156966Z",
     "shell.execute_reply": "2024-04-14T16:21:36.155985Z",
     "shell.execute_reply.started": "2024-04-14T16:21:36.151847Z"
    },
    "id": "KKt67LPn9YtB",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def seed_everything(seed=42):\n",
    "    random.seed(seed)\n",
    "    os.environ['PYTHONHASHSEED'] = str(seed)\n",
    "    np.random.seed(seed)\n",
    "    torch.manual_seed(seed)\n",
    "    torch.cuda.manual_seed(seed)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7bdb2a1d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-14T16:21:36.353134Z",
     "iopub.status.busy": "2024-04-14T16:21:36.352777Z",
     "iopub.status.idle": "2024-04-14T16:21:36.363087Z",
     "shell.execute_reply": "2024-04-14T16:21:36.362142Z",
     "shell.execute_reply.started": "2024-04-14T16:21:36.353107Z"
    },
    "id": "yXcFJ6IYkpiz",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def evaluate_model(cfg, model, data_loader, loss_criterion, epoch=-1):\n",
    "    # loss_fn = nn.CrossEntropyLoss(weight=cfg.weights.to(device), label_smoothing=0.1)\n",
    "    loss_fn = loss_criterion\n",
    "\n",
    "    model.eval()\n",
    "    val_loss = 0\n",
    "\n",
    "    targets = []\n",
    "    predictions = []\n",
    "\n",
    "    total_len = len(data_loader)\n",
    "    tk0 = tqdm(enumerate(data_loader), total=total_len)\n",
    "    for step, (images, labels) in tk0:\n",
    "        images = images.to(device, nonblocking=True)\n",
    "        target = labels.to(device, nonblocking=True)\n",
    "\n",
    "        with torch.no_grad():\n",
    "            ####################\n",
    "            embeddings = model(images)\n",
    "            loss = loss_fn(embeddings, target)\n",
    "            ####################\n",
    "\n",
    "        val_loss += loss.item()\n",
    "\n",
    "        targets.append(target.detach().cpu())\n",
    "        # predictions.append(logits.detach().cpu())\n",
    "        del images, target, logits\n",
    "\n",
    "    targets = torch.cat(targets, dim=0)\n",
    "    # predictions = torch.cat(predictions, dim=0)\n",
    "    # predictions = F.sigmoid(predictions)\n",
    "\n",
    "    val_loss /= total_len\n",
    "    # base_score, best_score, best_th = find_best_threshold(targets, predictions[:, 1])\n",
    "    # roc_auc = roc_auc_score(targets.numpy(), predictions[:, 1].numpy())\n",
    "    roc_auc = 1\n",
    "\n",
    "    print(f'Epoch {epoch} validation loss = {val_loss:.4f} auc = {roc_auc:.4f}')\n",
    "    return val_loss, roc_auc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d5e91de2",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-14T16:21:36.532561Z",
     "iopub.status.busy": "2024-04-14T16:21:36.532193Z",
     "iopub.status.idle": "2024-04-14T16:21:36.545367Z",
     "shell.execute_reply": "2024-04-14T16:21:36.544346Z",
     "shell.execute_reply.started": "2024-04-14T16:21:36.532533Z"
    },
    "id": "nZFniP2hkpi0",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def train_epoch(cfg, model, train_loader, loss_criterion, optimizer, scheduler, epoch):\n",
    "    scaler = torch.cuda.amp.GradScaler(enabled=cfg.apex)\n",
    "    # loss_fn = nn.CrossEntropyLoss(weight=cfg.weights.to(device), label_smoothing=0.1)\n",
    "    loss_fn = loss_criterion\n",
    "\n",
    "    model.train()\n",
    "    train_loss = 0\n",
    "    learning_rate_history = []\n",
    "\n",
    "    targets = []\n",
    "    predictions = []\n",
    "\n",
    "    total_len = len(train_loader)\n",
    "    tk0 = tqdm(enumerate(train_loader), total=total_len)\n",
    "    for step, (images, labels) in tk0:\n",
    "        images = images.to(device, non_blocking=True)\n",
    "        target = labels.to(device, non_blocking=True)\n",
    "\n",
    "        # https://pytorch.org/blog/accelerating-training-on-nvidia-gpus-with-pytorch-automatic-mixed-precision/\n",
    "        with torch.cuda.amp.autocast(enabled=cfg.apex):\n",
    "            ####################\n",
    "            embeddings = model(images)\n",
    "            loss = loss_fn(embeddings, target)\n",
    "            ####################\n",
    "\n",
    "        scaler.scale(loss).backward()\n",
    "        torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=cfg.clip_val)\n",
    "\n",
    "        train_loss += loss.item()\n",
    "        scaler.step(optimizer)\n",
    "        scaler.update()\n",
    "        optimizer.zero_grad()\n",
    "\n",
    "        if scheduler is None:\n",
    "            lr = optimizer.param_groups[0]['lr']\n",
    "        else:\n",
    "            scheduler.step()\n",
    "            lr = scheduler.get_last_lr()[0]\n",
    "\n",
    "        tk0.set_description(f\"Epoch {epoch} training {step+1}/{total_len} [LR {lr:0.6f}] - loss: {train_loss/(step+1):.4f}\")\n",
    "        learning_rate_history.append(lr)\n",
    "\n",
    "        # targets.append(target.detach().cpu())\n",
    "        # predictions.append(embeddings.detach().cpu())\n",
    "        del images, target\n",
    "\n",
    "    # targets = torch.cat(targets, dim=0)\n",
    "    # predictions = torch.cat(predictions, dim=0)\n",
    "    # predictions = F.sigmoid(predictions)\n",
    "\n",
    "    train_loss /= total_len\n",
    "    # roc_auc = roc_auc_score(targets.numpy(), predictions[:, 1].numpy())\n",
    "    roc_auc = 1\n",
    "\n",
    "    print(f'Epoch {epoch} train loss = {train_loss:.4f}, auc = {roc_auc:.4f}')\n",
    "    return train_loss, learning_rate_history, roc_auc"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dc8b9c5a",
   "metadata": {
    "id": "qN83vJk4xCA3",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Train model"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9dd72a75",
   "metadata": {
    "id": "8NyHYtzwZT8h",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Split data\n",
    "\n",
    "The distribution of classes in the training data is not balance so using StratifiedKFold will ensure that the distrubution of positive and negative samples in all folds will match the original distributions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "054932a9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-14T16:21:39.039930Z",
     "iopub.status.busy": "2024-04-14T16:21:39.039564Z",
     "iopub.status.idle": "2024-04-14T16:21:39.307011Z",
     "shell.execute_reply": "2024-04-14T16:21:39.306082Z",
     "shell.execute_reply.started": "2024-04-14T16:21:39.039904Z"
    },
    "id": "HaYXa749AEes",
    "outputId": "65b6c941-0e6e-4503-b513-574264d657ce",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# plt.figure(figsize=(4,2))\n",
    "# sns.histplot(train_data[\"label\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "673bec71",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-14T16:21:39.309571Z",
     "iopub.status.busy": "2024-04-14T16:21:39.308889Z",
     "iopub.status.idle": "2024-04-14T16:21:39.321211Z",
     "shell.execute_reply": "2024-04-14T16:21:39.320264Z",
     "shell.execute_reply.started": "2024-04-14T16:21:39.309534Z"
    },
    "id": "DRHeo8pr56FX",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from sklearn.model_selection import StratifiedKFold\n",
    "\n",
    "sgkf = StratifiedKFold(n_splits=CFG.N_folds, random_state=CFG.seed, shuffle=True)\n",
    "for i, (train_index, test_index) in enumerate(sgkf.split(train_data[\"image\"].values, train_data[\"level\"].values)):\n",
    "    train_data.loc[test_index, \"fold\"] = i"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9afb902a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-14T16:21:39.448281Z",
     "iopub.status.busy": "2024-04-14T16:21:39.447697Z",
     "iopub.status.idle": "2024-04-14T16:21:39.484233Z",
     "shell.execute_reply": "2024-04-14T16:21:39.483014Z",
     "shell.execute_reply.started": "2024-04-14T16:21:39.448249Z"
    },
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# from torchgeo import models\n",
    "# from torch import nn"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c76874e0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-14T16:21:40.091094Z",
     "iopub.status.busy": "2024-04-14T16:21:40.090402Z",
     "iopub.status.idle": "2024-04-14T16:21:40.096027Z",
     "shell.execute_reply": "2024-04-14T16:21:40.095120Z",
     "shell.execute_reply.started": "2024-04-14T16:21:40.091064Z"
    },
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def create_model():\n",
    "    ######################\n",
    "    model = timm.create_model(CFG.model_name, num_classes=0)\n",
    "    ######################\n",
    "    \n",
    "    # remove the last layer\n",
    "#     model.fc = nn.Linear(in_features=2048, out_features=2, bias=True)\n",
    "\n",
    "    return model.to(device)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a4ba8f84",
   "metadata": {
    "id": "rF9BFqS8AXBY",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Train folds"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8e1570b1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-14T16:21:40.983908Z",
     "iopub.status.busy": "2024-04-14T16:21:40.983523Z",
     "iopub.status.idle": "2024-04-14T16:21:48.524465Z",
     "shell.execute_reply": "2024-04-14T16:21:48.523002Z",
     "shell.execute_reply.started": "2024-04-14T16:21:40.983878Z"
    },
    "id": "7CFfmp3CxDG5",
    "outputId": "952103d3-bbd9-449f-e9cf-26d5c2608aea",
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "scrolled": true,
    "tags": []
   },
   "outputs": [],
   "source": [
    "for FOLD in CFG.train_folds:\n",
    "\n",
    "    seed_everything(CFG.seed)\n",
    "\n",
    "    # PREPARE DATA\n",
    "    fold_train_data = train_data[train_data[\"fold\"] != FOLD].reset_index(drop=True)\n",
    "    fold_valid_data = train_data[train_data[\"fold\"] == FOLD].reset_index(drop=True)\n",
    "\n",
    "    # display(\n",
    "    #     pd.merge(\n",
    "    #         fold_valid_data.groupby(by=[\"label\"])[\"file_name\"].count().rename(\"valid\").reset_index(),\n",
    "    #         fold_train_data.groupby(by=[\"label\"])[\"file_name\"].count().rename(\"train\").reset_index(),\n",
    "    #          on=\"label\", how=\"left\").T,)\n",
    "\n",
    "\n",
    "    train_dataset = ImageTrainDataset(TRAIN_DATA_FOLDER, fold_train_data, transforms=train_transforms)\n",
    "    valid_dataset = ImageTrainDataset(TRAIN_DATA_FOLDER, fold_valid_data, transforms=val_transforms)\n",
    "\n",
    "    train_loader = DataLoader(\n",
    "            train_dataset,\n",
    "            batch_size=CFG.batch_size,\n",
    "            shuffle=True,\n",
    "            num_workers=os.cpu_count(),\n",
    "            pin_memory=True,\n",
    "            drop_last=True\n",
    "        )\n",
    "\n",
    "    valid_loader = DataLoader(\n",
    "        valid_dataset,\n",
    "        batch_size=CFG.batch_size,\n",
    "        shuffle=False,\n",
    "        num_workers=os.cpu_count(),\n",
    "        pin_memory=True,\n",
    "        drop_last=False,\n",
    "    )\n",
    "\n",
    "    # PREPARE MODEL, OPTIMIZER AND SCHEDULER\n",
    "    model = create_model()\n",
    "    print(f\"Model parameters: {sum(p.numel() for p in model.parameters() if p.requires_grad):_}\")\n",
    "\n",
    "    optimizer = torch.optim.AdamW(model.parameters(), lr=CFG.lr, weight_decay=CFG.weight_decay)\n",
    "    scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(\n",
    "        optimizer, eta_min=1e-6, T_max =CFG.epochs * len(train_loader),\n",
    "        )\n",
    "    \n",
    "    loss_criterion = contrastive_loss\n",
    "\n",
    "    # TRAIN FOLD\n",
    "    learning_rate_history = []\n",
    "    train_loss_history = []\n",
    "    train_score_history = []\n",
    "    val_loss_history = []\n",
    "    val_score_history = []\n",
    "\n",
    "    best_score = 0\n",
    "    \n",
    "    wandb.run.tags = [f\"fold_{FOLD}\"]\n",
    "    \n",
    "    for epoch in range(0, CFG.epochs):\n",
    "        train_loss, train_lr, train_auc = train_epoch(CFG, model, train_loader, loss_criterion, optimizer, scheduler, epoch)\n",
    "        train_loss_history.append(train_loss)\n",
    "        train_score_history.append(train_auc)\n",
    "        learning_rate_history.extend(train_lr)\n",
    "\n",
    "        val_loss, val_auc = evaluate_model(CFG, model, valid_loader, loss_criterion, epoch)\n",
    "        val_loss_history.append(val_loss)\n",
    "        val_score_history.append(val_auc)\n",
    "        \n",
    "        wandb.log(\n",
    "            {'train': {'loss': train_loss, 'auc': train_auc}, \n",
    "             'val': {'loss': val_loss, 'auc': val_auc}})\n",
    "\n",
    "        if (val_auc >= best_score):\n",
    "            print(f\"{style.GREEN}New best score: {best_score:.4f} -> {val_auc:.4f}{style.END}\")\n",
    "            best_score = val_auc\n",
    "            torch.save(model.state_dict(), os.path.join(wandb.run.dir, f'best_model_fold_{FOLD}.pth'))\n",
    "            \n",
    "    # run.log_model(\n",
    "    #     path=os.path.join(wandb.run.dir, 'best_model_fold_{FOLD}'), \n",
    "    #     name=f'{CFG.model_name}_fold_{FOLD}'\n",
    "    # )\n",
    "\n",
    "    # # plot train and validation loss, score and LR\n",
    "    # fig, axes = plt.subplots(1,3, figsize=(12,3))\n",
    "    # axes[0].plot(train_loss_history, label=\"Train\")\n",
    "    # axes[0].plot(val_loss_history, label=\"Valid\")\n",
    "    # axes[0].title.set_text(\"Loss\")\n",
    "    # axes[0].set_xlabel(\"Epoch\")\n",
    "    # axes[0].legend()\n",
    "\n",
    "    # axes[1].plot(train_score_history, label=\"Train\")\n",
    "    # axes[1].plot(val_score_history, label=\"Valid\")\n",
    "    # axes[1].title.set_text(\"F1 score\")\n",
    "    # axes[1].set_xlabel(\"Epoch\")\n",
    "    # axes[1].legend()\n",
    "\n",
    "    # axes[2].plot(learning_rate_history, label=\"LR\")\n",
    "    # axes[2].legend()\n",
    "    # axes[2].title.set_text(\"Learning rate\")\n",
    "    # axes[2].set_xlabel(\"Step\")\n",
    "    # fig.suptitle(f\"Fold {FOLD}\")\n",
    "    # fig.tight_layout()\n",
    "    # plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d6f5f54d",
   "metadata": {
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "wandb.finish()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b627b45a",
   "metadata": {
    "papermill": {
     "duration": null,
     "end_time": null,
     "exception": null,
     "start_time": null,
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "accelerator": "GPU",
  "colab": {
   "provenance": [],
   "toc_visible": true
  },
  "kaggle": {
   "accelerator": "gpu",
   "dataSources": [
    {
     "datasetId": 4568125,
     "sourceId": 7801430,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 4568781,
     "sourceId": 7877494,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 30664,
   "isGpuEnabled": true,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 13.212713,
   "end_time": "2024-05-12T01:01:22.121860",
   "environment_variables": {},
   "exception": null,
   "input_path": "model_contrastive.ipynb",
   "output_path": "output/o3.ipyb",
   "parameters": {},
   "start_time": "2024-05-12T01:01:08.909147",
   "version": "2.6.0"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "08d2c86ce4ab4b9e813473170145d4af": {
     "model_module": "@jupyter-widgets/controls",
     "model_module_version": "1.5.0",
     "model_name": "HTMLModel",
     "state": {
      "_dom_classes": [],
      "_model_module": "@jupyter-widgets/controls",
      "_model_module_version": "1.5.0",
      "_model_name": "HTMLModel",
      "_view_count": null,
      "_view_module": "@jupyter-widgets/controls",
      "_view_module_version": "1.5.0",
      "_view_name": "HTMLView",
      "description": "",
      "description_tooltip": null,
      "layout": "IPY_MODEL_96fb1b36ead648c4a4ebebb74c9fcf2c",
      "placeholder": "​",
      "style": "IPY_MODEL_af10206931434c6fbfde31af25affbfa",
      "value": "model.safetensors: 100%"
     }
    },
    "103798aed0c64914b55a691a4d22253e": {
     "model_module": "@jupyter-widgets/controls",
     "model_module_version": "1.5.0",
     "model_name": "HTMLModel",
     "state": {
      "_dom_classes": [],
      "_model_module": "@jupyter-widgets/controls",
      "_model_module_version": "1.5.0",
      "_model_name": "HTMLModel",
      "_view_count": null,
      "_view_module": "@jupyter-widgets/controls",
      "_view_module_version": "1.5.0",
      "_view_name": "HTMLView",
      "description": "",
      "description_tooltip": null,
      "layout": "IPY_MODEL_4420cb88a6a74540a671a529e7320589",
      "placeholder": "​",
      "style": "IPY_MODEL_6b7cb0c6580d4caba2c4f8385749a145",
      "value": " 124M/124M [00:00&lt;00:00, 384MB/s]"
     }
    },
    "2831af4d288b45b688ba9b5992dce3f4": {
     "model_module": "@jupyter-widgets/controls",
     "model_module_version": "1.5.0",
     "model_name": "FloatProgressModel",
     "state": {
      "_dom_classes": [],
      "_model_module": "@jupyter-widgets/controls",
      "_model_module_version": "1.5.0",
      "_model_name": "FloatProgressModel",
      "_view_count": null,
      "_view_module": "@jupyter-widgets/controls",
      "_view_module_version": "1.5.0",
      "_view_name": "ProgressView",
      "bar_style": "success",
      "description": "",
      "description_tooltip": null,
      "layout": "IPY_MODEL_a3763df1b6564f319afc8d67073af72f",
      "max": 124450218,
      "min": 0,
      "orientation": "horizontal",
      "style": "IPY_MODEL_a4c3f492a9b946a0b72df7ea6bb188a9",
      "value": 124450218
     }
    },
    "4420cb88a6a74540a671a529e7320589": {
     "model_module": "@jupyter-widgets/base",
     "model_module_version": "1.2.0",
     "model_name": "LayoutModel",
     "state": {
      "_model_module": "@jupyter-widgets/base",
      "_model_module_version": "1.2.0",
      "_model_name": "LayoutModel",
      "_view_count": null,
      "_view_module": "@jupyter-widgets/base",
      "_view_module_version": "1.2.0",
      "_view_name": "LayoutView",
      "align_content": null,
      "align_items": null,
      "align_self": null,
      "border": null,
      "bottom": null,
      "display": null,
      "flex": null,
      "flex_flow": null,
      "grid_area": null,
      "grid_auto_columns": null,
      "grid_auto_flow": null,
      "grid_auto_rows": null,
      "grid_column": null,
      "grid_gap": null,
      "grid_row": null,
      "grid_template_areas": null,
      "grid_template_columns": null,
      "grid_template_rows": null,
      "height": null,
      "justify_content": null,
      "justify_items": null,
      "left": null,
      "margin": null,
      "max_height": null,
      "max_width": null,
      "min_height": null,
      "min_width": null,
      "object_fit": null,
      "object_position": null,
      "order": null,
      "overflow": null,
      "overflow_x": null,
      "overflow_y": null,
      "padding": null,
      "right": null,
      "top": null,
      "visibility": null,
      "width": null
     }
    },
    "6b7cb0c6580d4caba2c4f8385749a145": {
     "model_module": "@jupyter-widgets/controls",
     "model_module_version": "1.5.0",
     "model_name": "DescriptionStyleModel",
     "state": {
      "_model_module": "@jupyter-widgets/controls",
      "_model_module_version": "1.5.0",
      "_model_name": "DescriptionStyleModel",
      "_view_count": null,
      "_view_module": "@jupyter-widgets/base",
      "_view_module_version": "1.2.0",
      "_view_name": "StyleView",
      "description_width": ""
     }
    },
    "87901707be784b03998e8b8093255ea6": {
     "model_module": "@jupyter-widgets/base",
     "model_module_version": "1.2.0",
     "model_name": "LayoutModel",
     "state": {
      "_model_module": "@jupyter-widgets/base",
      "_model_module_version": "1.2.0",
      "_model_name": "LayoutModel",
      "_view_count": null,
      "_view_module": "@jupyter-widgets/base",
      "_view_module_version": "1.2.0",
      "_view_name": "LayoutView",
      "align_content": null,
      "align_items": null,
      "align_self": null,
      "border": null,
      "bottom": null,
      "display": null,
      "flex": null,
      "flex_flow": null,
      "grid_area": null,
      "grid_auto_columns": null,
      "grid_auto_flow": null,
      "grid_auto_rows": null,
      "grid_column": null,
      "grid_gap": null,
      "grid_row": null,
      "grid_template_areas": null,
      "grid_template_columns": null,
      "grid_template_rows": null,
      "height": null,
      "justify_content": null,
      "justify_items": null,
      "left": null,
      "margin": null,
      "max_height": null,
      "max_width": null,
      "min_height": null,
      "min_width": null,
      "object_fit": null,
      "object_position": null,
      "order": null,
      "overflow": null,
      "overflow_x": null,
      "overflow_y": null,
      "padding": null,
      "right": null,
      "top": null,
      "visibility": null,
      "width": null
     }
    },
    "96fb1b36ead648c4a4ebebb74c9fcf2c": {
     "model_module": "@jupyter-widgets/base",
     "model_module_version": "1.2.0",
     "model_name": "LayoutModel",
     "state": {
      "_model_module": "@jupyter-widgets/base",
      "_model_module_version": "1.2.0",
      "_model_name": "LayoutModel",
      "_view_count": null,
      "_view_module": "@jupyter-widgets/base",
      "_view_module_version": "1.2.0",
      "_view_name": "LayoutView",
      "align_content": null,
      "align_items": null,
      "align_self": null,
      "border": null,
      "bottom": null,
      "display": null,
      "flex": null,
      "flex_flow": null,
      "grid_area": null,
      "grid_auto_columns": null,
      "grid_auto_flow": null,
      "grid_auto_rows": null,
      "grid_column": null,
      "grid_gap": null,
      "grid_row": null,
      "grid_template_areas": null,
      "grid_template_columns": null,
      "grid_template_rows": null,
      "height": null,
      "justify_content": null,
      "justify_items": null,
      "left": null,
      "margin": null,
      "max_height": null,
      "max_width": null,
      "min_height": null,
      "min_width": null,
      "object_fit": null,
      "object_position": null,
      "order": null,
      "overflow": null,
      "overflow_x": null,
      "overflow_y": null,
      "padding": null,
      "right": null,
      "top": null,
      "visibility": null,
      "width": null
     }
    },
    "a3763df1b6564f319afc8d67073af72f": {
     "model_module": "@jupyter-widgets/base",
     "model_module_version": "1.2.0",
     "model_name": "LayoutModel",
     "state": {
      "_model_module": "@jupyter-widgets/base",
      "_model_module_version": "1.2.0",
      "_model_name": "LayoutModel",
      "_view_count": null,
      "_view_module": "@jupyter-widgets/base",
      "_view_module_version": "1.2.0",
      "_view_name": "LayoutView",
      "align_content": null,
      "align_items": null,
      "align_self": null,
      "border": null,
      "bottom": null,
      "display": null,
      "flex": null,
      "flex_flow": null,
      "grid_area": null,
      "grid_auto_columns": null,
      "grid_auto_flow": null,
      "grid_auto_rows": null,
      "grid_column": null,
      "grid_gap": null,
      "grid_row": null,
      "grid_template_areas": null,
      "grid_template_columns": null,
      "grid_template_rows": null,
      "height": null,
      "justify_content": null,
      "justify_items": null,
      "left": null,
      "margin": null,
      "max_height": null,
      "max_width": null,
      "min_height": null,
      "min_width": null,
      "object_fit": null,
      "object_position": null,
      "order": null,
      "overflow": null,
      "overflow_x": null,
      "overflow_y": null,
      "padding": null,
      "right": null,
      "top": null,
      "visibility": null,
      "width": null
     }
    },
    "a4c3f492a9b946a0b72df7ea6bb188a9": {
     "model_module": "@jupyter-widgets/controls",
     "model_module_version": "1.5.0",
     "model_name": "ProgressStyleModel",
     "state": {
      "_model_module": "@jupyter-widgets/controls",
      "_model_module_version": "1.5.0",
      "_model_name": "ProgressStyleModel",
      "_view_count": null,
      "_view_module": "@jupyter-widgets/base",
      "_view_module_version": "1.2.0",
      "_view_name": "StyleView",
      "bar_color": null,
      "description_width": ""
     }
    },
    "af10206931434c6fbfde31af25affbfa": {
     "model_module": "@jupyter-widgets/controls",
     "model_module_version": "1.5.0",
     "model_name": "DescriptionStyleModel",
     "state": {
      "_model_module": "@jupyter-widgets/controls",
      "_model_module_version": "1.5.0",
      "_model_name": "DescriptionStyleModel",
      "_view_count": null,
      "_view_module": "@jupyter-widgets/base",
      "_view_module_version": "1.2.0",
      "_view_name": "StyleView",
      "description_width": ""
     }
    },
    "b53d0ba4ae3e496092fdf021cb4097aa": {
     "model_module": "@jupyter-widgets/controls",
     "model_module_version": "1.5.0",
     "model_name": "HBoxModel",
     "state": {
      "_dom_classes": [],
      "_model_module": "@jupyter-widgets/controls",
      "_model_module_version": "1.5.0",
      "_model_name": "HBoxModel",
      "_view_count": null,
      "_view_module": "@jupyter-widgets/controls",
      "_view_module_version": "1.5.0",
      "_view_name": "HBoxView",
      "box_style": "",
      "children": [
       "IPY_MODEL_08d2c86ce4ab4b9e813473170145d4af",
       "IPY_MODEL_2831af4d288b45b688ba9b5992dce3f4",
       "IPY_MODEL_103798aed0c64914b55a691a4d22253e"
      ],
      "layout": "IPY_MODEL_87901707be784b03998e8b8093255ea6"
     }
    }
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}